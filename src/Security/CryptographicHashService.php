<?php
namespace SilverStripe\Security;

use InvalidArgumentException;
use SilverStripe\Core\Config\Configurable;
use SilverStripe\Core\Injector\Injectable;
use SilverStripe\Core\Injector\Injector;
use SilverStripe\Security\HashMethod\HashMethodInterface;
use SilverStripe\Security\HashMethod\LegacyMemberHash;
use SilverStripe\Security\HashMethod\PhpPasswordHash;

class CryptographicHashService
{
    use Configurable;
    use Injectable;

    const IDENTIFIER_SEPARATOR = '**';

    private static $hash_methods = [
        PhpPasswordHash::class,
        LegacyMemberHash::class,
    ];

    private static $default_hash_method = null;

    /**
     * The current hash method this service is configured to use
     *
     * @var HashMethodInterface
     */
    protected $hashMethod;

    /**
     * A lazily loaded list of all HashMethod instances that are configured
     *
     * @var HashMethodInterface[]
     */
    protected $allHashMethods;

    /**
     * @param HashMethodInterface $hashMethod
     */
    public function __construct(HashMethodInterface $hashMethod = null)
    {
        if (!$hashMethod) {
            $hashMethod = $this->getDefaultHashMethod();
        }
        $this->hashMethod = $hashMethod;
    }

    /**
     * Generate a hash from the given plaintext
     *
     * @param string $plaintext
     * @return string
     */
    public function hash($plaintext)
    {
        $hashMethod = $this->hashMethod;
        return $this->exportHashMethod($hashMethod->hash($plaintext));
    }

    /**
     * Verify the given plaintext matches the given hash with a timing safe comparison
     *
     * @param string $plaintext
     * @param string $hash
     * @return bool
     */
    public function verify($plaintext, $hash)
    {
        /** @var HashMethodInterface $hashMethod */
        list($hashMethod, $hash) = $this->extractHashMethod($hash);
        return $hashMethod->verify($plaintext, $hash);
    }

    /**
     * Identify if the given hash should be rehashed or not
     *
     * @param $hash
     * @return bool
     */
    public function needsRehash($hash)
    {
        /** @var HashMethodInterface $hashMethod */
        list($hashMethod, $hash) = $this->extractHashMethod($hash);

        if ($hashMethod->identifier() !== $this->hashMethod->identifier()) {
            return true;
        }

        return $hashMethod->needsRehash($hash);
    }

    /**
     * @return HashMethodInterface
     */
    public function getHashMethod()
    {
        return $this->hashMethod;
    }

    /**
     * Override the configured HashMethod for hashes generated by this service
     *
     * @param HashMethodInterface $hashMethod
     * @return $this
     */
    public function setHashMethod(HashMethodInterface $hashMethod)
    {
        $this->hashMethod = $hashMethod;
        return $this;
    }

    /**
     * Return the HashMethod and the transformed hash for the given hash
     *
     * @param string $hash
     * @return array [HashMethodInterface, $hash]
     */
    protected function extractHashMethod($hash)
    {
        $separator = strpos($hash, self::IDENTIFIER_SEPARATOR);
        if (!$separator) {
            throw new InvalidArgumentException(sprintf(
                'Invalid hash given to %s. Could not determine the hash method used to create the given hash.',
                __CLASS__
            ));
        }

        $method = substr($hash, 0, $separator);
        $hash = substr($hash, $separator + strlen(self::IDENTIFIER_SEPARATOR));

        $hashMethods = $this->getAllHashMethods();
        if (isset($hashMethods[$method])) {
            return [$hashMethods[$method], $hash];
        }

        throw new InvalidArgumentException(sprintf(
            'There is no configured hash method that matches the given identifier "%s"',
            $method
        ));
    }

    /**
     * Export detail about the configured hash method within the given hash
     *
     * @param $hash
     * @return string Updated hash
     */
    protected function exportHashMethod($hash)
    {
        return $this->hashMethod->identifier() . self::IDENTIFIER_SEPARATOR . $hash;
    }

    /**
     * Get instances of all configured hash methods
     *
     * @return HashMethodInterface[]
     */
    protected function getAllHashMethods()
    {
        if ($this->allHashMethods === null) {
            $hashMethods = [];
            foreach ($this->getConfiguredHashMethods() as $hashMethod) {
                $hashMethod = Injector::inst()->create($hashMethod);
                $hashMethods[$hashMethod->identifier()] = $hashMethod;
            }
            $this->allHashMethods = $hashMethods;
        }

        return $this->allHashMethods;
    }

    /**
     * Get the configured default hash method
     *
     * @return HashMethodInterface
     */
    protected function getDefaultHashMethod()
    {
        return Injector::inst()->create(self::config()->get('default_hash_method'));
    }

    /**
     * @return mixed
     */
    protected function getConfiguredHashMethods()
    {
        return self::config()->get('hash_methods');
    }
}
